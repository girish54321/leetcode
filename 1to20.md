## 1. Two Sum
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.


Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]

```js
var twoSum = function(nums, target) {
    let myMap = new Map()

    for (let i = 0; i < nums.length; i++){
        let item = nums[i]
        let remander = target - item
        if (myMap.has(remander)) {
            return [i, myMap.get(remander)]
        } else {
            myMap.set(item,i)
        }
    }
};
```

## 2. Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.


Example 1:
![alt text](image-1.png)

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.

Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]

Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
var addTwoNumbers = function(l1, l2) {
    let dummy = new ListNode(0)
    let myLinkedList = dummy
    let carry = 0

    while (l1 != null || l2 != null || carry > 0) {
        sum = carry

        if(l1 != null) {
            sum = sum + l1.val
            l1 = l1.next
        }
        if(l2 != null) {
            sum = sum + l2.val
            l2 = l2.next
        }

        carry = Math.floor(sum / 10) // if sum is 15 the it will be come 1
        let myNumber = sum % 10 // if sum is 15 then it becomes 5

        myLinkedList.next = new ListNode(myNumber)
        myLinkedList = myLinkedList.next    
    } 
    return dummy.next
};
```

## 3. Longest Substring Without Repeating Characters

Given a string s, find the length of the longest

without duplicate characters.

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.

Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

```js
var lengthOfLongestSubstring = function(s) {
    let mySet = new Set()
    let left = 0
    let maxCount = 0

    for (let right = 0; right < s.length; right++){
        while (mySet.has(s[right])) {
            // If the current character is already in the set,
            // remove the character at the 'left' pointer and move 'left' to the right
            mySet.delete(s[left]);  // Remove character at 'left'
            left++;  // Move the 'left' pointer one step to the right
        }

        // Now, the character at 'right' can safely be added to the set
        mySet.add(s[right]);  // Add the current character at 'right' to the set

        maxCount = Math.max(maxCount,right - left + 1) // "+" is needed due to index start with 0 but 
        // we need to + 1 to get count as count will be less then 1 
    }
    return maxCount
}
```

## 4. Median of Two Sorted Arrays

Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

```js
var findMedianSortedArrays = function(nums1, nums2) {
   let newArray = [...nums1,...nums2].sort((a,b)=> a - b)
   let arraySize = newArray.length

   if(arraySize % 2 === 0){
     let m1 = newArray[arraySize/2]
     let m2 = newArray[(arraySize/2) - 1]
     return (m1 + m2) / 2
   } else {
      return newArray[Math.floor(arraySize/2)]
   }
};
```

## 5. Longest Palindromic Substring
Given a string s, return the longest

in s.

Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

Example 2:

Input: s = "cbbd"
Output: "bb"
 

 ```js
var checkPalindrome = function(s,right,left) {
    while (left >= 0 && right < s.length && s[right] === s[left]) {
        left--
        right++
    }
    return s.slice(left + 1, right)
}

var longestPalindrome = function(s) {
   if (s.length < 2) return s

   let result = ""

    for (let i = 0; i < s.length; i++) {
        let isEven = checkPalindrome(s,i,i)
        let isOod = checkPalindrome(s,i,i+1)

        let longPalindrome = isEven.length > isOod.length ? isEven : isOod
        if(result.length < longPalindrome.length) {
            result = longPalindrome
        }
    }
    return result
}

```

## 6. Zigzag Conversion
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R

And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
 
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"

Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I

Example 3:

Input: s = "A", numRows = 1
Output: "A"

```js
var convert = function(s, numRows) {
    if(s.length < 2 || numRows < 2){
        return s
    }

    let count = 0
    let dircation = false
    let myArray = new Array(numRows).fill("")

    for (let i = 0; i < s.length; i++) {
        let item = s[i]
        myArray[count] += item

        if(count == 0 || count >= numRows - 1){
            dircation = !dircation
        }

        if(dircation){
            count++
        } else {
            count--
        }
    }
    return myArray.join("")
};
```

## 7. Reverse Integer

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

Example 1:

Input: x = 123
Output: 321

Example 2:

Input: x = -123
Output: -321

Example 3:

Input: x = 120
Output: 21

```js
var reverse = function(x) {
    if(x < 0) return -1 * reverse(-x)
    const myNumber = (x+"").split('').reverse().join('')
    if(parseInt(myNumber) === 2147483651) return 0
    return (myNumber > 2**32 -1) ? 0 : parseInt(myNumber)
};
```

## 8. String to Integer (atoi)

Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.

The algorithm for myAtoi(string s) is as follows:

    Whitespace: Ignore any leading whitespace (" ").
    Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.
    Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.
    Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.

Return the integer as the final result.

Example 1:

Input: s = "42"

Output: 42

Explanation:

The underlined characters are what is read in and the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "42" ("42" is read in)

```js
var myAtoi = function(s) {
    s = s.trim()
    if(s.length === 0) {
        return 0
    }
    
    let sign = 1
    let index = 0

    if(s[index] === '-' || s[index] === '+') {
        if (s[index] === '-') {
            sign = -1
        } else if(s[index] === '+') {
            sign = 1
        }
        index++
    }

    let sum = 0
    while (index < s.length && s[index] >= '0' && s[index] <= '9') {
        sum = sum * 10 + (s[index].charCodeAt(0) - '0'.charCodeAt(0))
        index++
    }

    sum = sum * sign;

    let INT_MIN = -(2 ** 31);
    let INT_MAX = 2 ** 31 - 1;

    if (sum < INT_MIN) return INT_MIN;
    if (sum > INT_MAX) return INT_MAX;

    return sum;
};
```

## 9. Palindrome Number
Given an integer x, return true if x is a

, and false otherwise.

Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.

Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

```js
var isPalindrome = function(x) {
    // negative numbers can't be palindrome
    if (x < 0) return false;

    // convert number to string
    let str = x.toString();

    // check if string is same as its reverse
    let reversed = str.split("").reverse().join("");
    return str === reversed;
};
```

## 10. Regular Expression Matching
Solved
Hard
Topics
premium lock iconCompanies

Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:

    '.' Matches any single character.​​​​
    '*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

 

Example 1:

Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".

Example 2:

Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".

Example 3:

Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".

```js
var isMatch = function(s, p) {
    // base case: if pattern is empty
    if (p.length === 0) return s.length === 0;

    // first match: check if first char matches (or if '.' is present)
    let firstMatch = (s.length > 0 && (s[0] === p[0] || p[0] === '.'));

    // if next char in pattern is '*'
    if (p.length >= 2 && p[1] === '*') {
        // two options:
        // 1. Skip "x*" part in pattern
        // 2. If firstMatch, use one char from s and keep p same
        return (
            isMatch(s, p.slice(2)) || 
            (firstMatch && isMatch(s.slice(1), p))
        );
    } else {
        // no '*', just move forward one step if match
        return firstMatch && isMatch(s.slice(1), p.slice(1));
    }
};

```

## 11. Container With Most Water
Solved
Medium
Topics
premium lock iconCompanies
Hint

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

![alt text](image.png)

Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

Example 2:

Input: height = [1,1]
Output: 1

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let left = 0
    let right = height.length - 1
    let maxWater = 0

    while (left < right) {
        let width = right - left
        let localHeight = Math.min(height[left],height[right])

        let area = width * localHeight
        maxWater = Math.max(maxWater,area)

        if(height[left] < height[right]) {
            left++
        } else {
            right--
        }
    }
    return maxWater
};
```

## 12. Integer to Roman

Seven different symbols represent Roman numerals with the following values:
| Symbol | Value |
|--------|-------|
| I      | 1     |
| V      | 5     |
| X      | 10    |
| L      | 50    |
| C      | 100   |
| D      | 500   |
| M      | 1000  |

```js
var intToRoman = function(num) {
    // Mapping of Roman symbols to values (including special cases)
    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    const symbols = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];

    let result = "";

    for (let i = 0; i < values.length; i++) {
        while (num >= values[i]) {
            num -= values[i];         // subtract the value
            result += symbols[i];     // add matching symbol
        }
    }

    return result;
};
```
Explanation for 1994

1000 → M → 994 left

900 → CM → 94 left

90 → XC → 4 left

4 → IV → done ✅
Result: "MCMXCIV"

## 13. Roman to Integer

Example 1:

Input: s = "III"
Output: 3
Explanation: III = 3.

Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.

Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

```js
var romanToInt = function(s) {
    const values  = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    const symbols = ["M", "CM","D", "CD","C","XC","L","XL","X","IX","V","IV","I"];
 
    let myNumber = 0
    let i = 0

    while (i < s.length) {
        // check of 2 char 
        if( i + 1 < s.length) {
            let twoChar = s.substring(i,i+2)
            let twoCharIndex = symbols.indexOf(twoChar)
            if(twoCharIndex !== -1) {
                myNumber = myNumber + values[twoCharIndex]
                i = i + 2
                continue 
            }
        }

        let oneChar = s[i]
        let oneCharIndex = symbols.indexOf(oneChar)
        if(oneCharIndex !== -1) {
            myNumber = myNumber + values[oneCharIndex]
            i = i + 1
        }
    }
    return myNumber
};

```

## 14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"

Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

```js
var longestCommonPrefix = function(strs) {
    strs.sort()

    let firstText = strs[0]
    let lastText = strs[strs.length - 1]
    let result = ""

    for (let i = 0; i < lastText.length; i++) {
        if(firstText[i] !== lastText[i]) {
            break;
        } else {
            result = result + firstText[i]
        }
    }
    return result
};
```

## 15. 3Sum

```js
 var threeSum = function(nums) {
    let result = []
    nums.sort((a,b) => a - b);
    
    // if(nums.length < 3) return []

    for (let i = 0; i < nums.length - 2; i++) {
        if(i > 0 && nums[i] === nums[i - 1]) continue;

        let left = i + 1
        let right = nums.length - 1
        while (left < right) {
            let sum = nums[i] + nums[left] + nums[right]
            if(sum === 0) {
                result.push([nums[i] , nums[left] , nums[right]])
                while (left < right && nums[left] === nums[left + 1]) left++
                while (left < right && nums[right] === nums[right - 1]) right--
                left++
                right--
            } else if (sum < 0){
                left++
            } else {
                right--
            }
        }
    }
    return result
};

```

## 16. 3Sum Closest

Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.

Example 1:

Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

Example 2:

Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).

```js
var threeSumClosest = function(nums, target) {
    nums.sort((a, b) => a - b);
    let closetNumer = nums[0] + nums[1] + nums[2]
    
    for (let i = 0; i < nums.length - 2; i++) {
        let left = i + 1
        let right = nums.length - 1

        while (left < right) {
            let sum = nums[i] + nums[left] + nums[right]

            if(Math.abs(sum - target) < Math.abs(closetNumer - target)) {
                closetNumer = sum
            }

            if(sum < target) {
                left++
            } else if (sum > target) {
                right--
            } else {
                return closetNumer
            }
        }
    }
    return closetNumer
};
```

## 17. Letter Combinations of a Phone Number

Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![alt text](image-2.png)

Example 1:

Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

Example 2:

Input: digits = ""
Output: []

Example 3:

Input: digits = "2"
Output: ["a","b","c"]

```js
var letterCombinations = function(digits) {
    if (digits.length === 0) return [];

    const phoneMap = {
        "2": "abc",
        "3": "def",
        "4": "ghi",
        "5": "jkl",
        "6": "mno",
        "7": "pqrs",
        "8": "tuv",
        "9": "wxyz"
    };
    // My Code
    let result = []

    let backStack = (index,path) => {
        if(path.length === digits.length) {
            result.push(path)
            return;
        }

        let letters = phoneMap[digits[index]]
        for(letter of letters) {
            backStack(index + 1, path + letter)
        }
    }

    backStack(0,"")
    return result
}
```

## 18. 4Sum

Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

    0 <= a, b, c, d < n
    a, b, c, and d are distinct.
    nums[a] + nums[b] + nums[c] + nums[d] == target

You may return the answer in any order.

 

Example 1:

Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

Example 2:

Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]

```js
var fourSum = function(nums, target) {
    let result = []
    nums.sort((a,b) => a - b)

    let n = nums.length

    for (let i = 0; i < n - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;

        for (let j = i + 1; j < n - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) continue;

            let left = j + 1
            let right = n - 1

            while(left < right) {
                let sum = nums[i] + nums[j] + nums[left] + nums[right]
                if(sum === target) {
                    result.push([nums[i],nums[j],nums[left],nums[right]])

                    while(left < right && nums[left] === nums[left + 1]) left++
                    while(left < right && nums[right] === nums[right - 1]) right--
                    right--
                    left++
                } else if (sum < target) {
                    left++
                } else {
                    right--
                }
            }
        }
    }
    return result
};

```

## 19. Remove Nth Node From End of List

![alt text](image-3.png)

Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:

Input: head = [1], n = 1
Output: []

Example 3:

Input: head = [1,2], n = 1
Output: [1]

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(0,head)
    let fast = dummy
    let slow = dummy

    for (let i = 0; i <= n; i++) {
        fast = fast.next
    }

    while (fast) {
        fast = fast.next
        slow = slow.next
    }

    slow.next = slow.next.next
    return dummy.next
};
```

## 20. Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

    Open brackets must be closed by the same type of brackets.
    Open brackets must be closed in the correct order.
    Every close bracket has a corresponding open bracket of the same type.

Example 1:

Input: s = "()"

Output: true

Example 2:

Input: s = "()[]{}"

Output: true

```js
var isValid = function(s) {
     let myStack = []
     let myMap = {
        '[':']',
        '{':'}',
        '(':')'
     }

     for (let char of s) {
        if (char === '[' || char === '(' || char === '{') {
            myStack.push(myMap[char])
        } else {
            if(myStack.length === 0 || myStack.pop() !== char){
                return false
            }
        }
     }

     return myStack.length === 0
};

```

## 21. Merge Two Sorted Lists

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

![alt text](image-4.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(list1, list2) {
    let dummy = new ListNode(0)
    let myLinkedList = dummy

    while (list1 !== null && list2 !== null) {
        if (list1.val < list2.val) {
            myLinkedList.next = list1
            list1 = list1.next
        } else {
            myLinkedList.next = list2
            list2 = list2.next
        }
        
        myLinkedList = myLinkedList.next
    }

    if(list1 != null) {
        myLinkedList.next = list1
    } else {
        myLinkedList.next = list2
    }

    return dummy.next
};
```

## 22. Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.


Example 1:

Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]

Example 2:

Input: n = 1
Output: ["()"]

```js
var generateParenthesis = function(n) {
    let result = [];

    function backtrack(current, open, close) {
        // if the string is complete
        if (current.length === n * 2) {
            result.push(current);
            return;
        }

        // if we can add "(", do it
        if (open < n) {
            backtrack(current + "(", open + 1, close);
        }

        // if we can add ")", do it
        if (close < open) {
            backtrack(current + ")", open, close + 1);
        }
    }

    backtrack("", 0, 0); // start with empty string
    return result;
};

```

## 23. Merge k Sorted Lists
Solved
Hard
Topics
premium lock iconCompanies

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

 

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted linked list:
1->1->2->3->4->4->5->6

Example 2:

Input: lists = []
Output: []

Example 3:

Input: lists = [[]]
Output: []

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if (lists.length === 0) return null;

    // Helper to merge 2 lists (from LeetCode 21)
    function mergeTwoLists(l1, l2) {
        let dummy = new ListNode(0);
        let current = dummy;

        while (l1 !== null && l2 !== null) {
            if (l1.val < l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        current.next = l1 || l2;
        return dummy.next;
    }

    // Merge lists in pairs until only one remains
    while (lists.length > 1) {
        let mergedLists = [];

        for (let i = 0; i < lists.length; i += 2) {
            let l1 = lists[i];
            let l2 = (i + 1 < lists.length) ? lists[i + 1] : null;
            mergedLists.push(mergeTwoLists(l1, l2));
        }

        lists = mergedLists; // reduce problem size
    }

    return lists[0];
};

```

## 24. Swap Nodes in Pairs
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

 

Example 1:

Input: head = [1,2,3,4]

Output: [2,1,4,3]

Explanation:

Example 2:

Input: head = []

Output: []

Example 3:

Input: head = [1]

Output: [1]

Example 4:

Input: head = [1,2,3]

Output: [2,1,3]

![alt text](image-5.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let dummy = new ListNode(0,head); // create a dummy node
    // dummy.next = head;
    let prev = dummy;

    while (head && head.next) {
        // Nodes to swap
        let first = head;
        let second = head.next;

        // Swapping
        prev.next = second;
        first.next = second.next;
        second.next = first;

        // Move pointers
        prev = first;
        head = first.next;
    }

    return dummy.next;
};

```