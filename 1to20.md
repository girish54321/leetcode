## 1. Two Sum
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.


Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]

```js
var twoSum = function(nums, target) {
    let myMap = new Map()

    for (let i = 0; i < nums.length; i++){
        let item = nums[i]
        let remander = target - item
        if (myMap.has(remander)) {
            return [i, myMap.get(remander)]
        } else {
            myMap.set(item,i)
        }
    }
};
```

## 2. Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.


Example 1:
![alt text](image-1.png)

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.

Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]

Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
var addTwoNumbers = function(l1, l2) {
    let dummy = new ListNode(0)
    let myLinkedList = dummy
    let carry = 0

    while (l1 != null || l2 != null || carry > 0) {
        sum = carry

        if(l1 != null) {
            sum = sum + l1.val
            l1 = l1.next
        }
        if(l2 != null) {
            sum = sum + l2.val
            l2 = l2.next
        }

        carry = Math.floor(sum / 10) // if sum is 15 the it will be come 1
        let myNumber = sum % 10 // if sum is 15 then it becomes 5

        myLinkedList.next = new ListNode(myNumber)
        myLinkedList = myLinkedList.next    
    } 
    return dummy.next
};
```

## 3. Longest Substring Without Repeating Characters

Given a string s, find the length of the longest

without duplicate characters.

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.

Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

```js
var lengthOfLongestSubstring = function(s) {
    let mySet = new Set()
    let left = 0
    let maxCount = 0

    for (let right = 0; right < s.length; right++){
        while (mySet.has(s[right])) {
            // If the current character is already in the set,
            // remove the character at the 'left' pointer and move 'left' to the right
            mySet.delete(s[left]);  // Remove character at 'left'
            left++;  // Move the 'left' pointer one step to the right
        }

        // Now, the character at 'right' can safely be added to the set
        mySet.add(s[right]);  // Add the current character at 'right' to the set

        maxCount = Math.max(maxCount,right - left + 1) // "+" is needed due to index start with 0 but 
        // we need to + 1 to get count as count will be less then 1 
    }
    return maxCount
}
```

## 4. Median of Two Sorted Arrays

Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

```js
var findMedianSortedArrays = function(nums1, nums2) {
   let newArray = [...nums1,...nums2].sort((a,b)=> a - b)
   let arraySize = newArray.length

   if(arraySize % 2 === 0){
     let m1 = newArray[arraySize/2]
     let m2 = newArray[(arraySize/2) - 1]
     return (m1 + m2) / 2
   } else {
      return newArray[Math.floor(arraySize/2)]
   }
};
```

## 5. Longest Palindromic Substring
Given a string s, return the longest

in s.

Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

Example 2:

Input: s = "cbbd"
Output: "bb"
 

 ```js
var checkPalindrome = function(s,right,left) {
    while (left >= 0 && right < s.length && s[right] === s[left]) {
        left--
        right++
    }
    return s.slice(left + 1, right)
}

var longestPalindrome = function(s) {
   if (s.length < 2) return s

   let result = ""

    for (let i = 0; i < s.length; i++) {
        let isEven = checkPalindrome(s,i,i)
        let isOod = checkPalindrome(s,i,i+1)

        let longPalindrome = isEven.length > isOod.length ? isEven : isOod
        if(result.length < longPalindrome.length) {
            result = longPalindrome
        }
    }
    return result
}

```

## 6. Zigzag Conversion
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R

And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
 
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"

Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I

Example 3:

Input: s = "A", numRows = 1
Output: "A"

```js
var convert = function(s, numRows) {
    if(s.length < 2 || numRows < 2){
        return s
    }

    let count = 0
    let dircation = false
    let myArray = new Array(numRows).fill("")

    for (let i = 0; i < s.length; i++) {
        let item = s[i]
        myArray[count] += item

        if(count == 0 || count >= numRows - 1){
            dircation = !dircation
        }

        if(dircation){
            count++
        } else {
            count--
        }
    }
    return myArray.join("")
};
```

## 7. Reverse Integer

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

Example 1:

Input: x = 123
Output: 321

Example 2:

Input: x = -123
Output: -321

Example 3:

Input: x = 120
Output: 21

```js
var reverse = function(x) {
    if(x < 0) return -1 * reverse(-x)
    const myNumber = (x+"").split('').reverse().join('')
    if(parseInt(myNumber) === 2147483651) return 0
    return (myNumber > 2**32 -1) ? 0 : parseInt(myNumber)
};
```

## 8. String to Integer (atoi)

Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.

The algorithm for myAtoi(string s) is as follows:

    Whitespace: Ignore any leading whitespace (" ").
    Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.
    Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.
    Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.

Return the integer as the final result.

Example 1:

Input: s = "42"

Output: 42

Explanation:

The underlined characters are what is read in and the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "42" ("42" is read in)

```js
var myAtoi = function(s) {
    s = s.trim()
    if(s.length === 0) {
        return 0
    }
    
    let sign = 1
    let index = 0

    if(s[index] === '-' || s[index] === '+') {
        if (s[index] === '-') {
            sign = -1
        } else if(s[index] === '+') {
            sign = 1
        }
        index++
    }

    let sum = 0
    while (index < s.length && s[index] >= '0' && s[index] <= '9') {
        sum = sum * 10 + (s[index].charCodeAt(0) - '0'.charCodeAt(0))
        index++
    }

    sum = sum * sign;

    let INT_MIN = -(2 ** 31);
    let INT_MAX = 2 ** 31 - 1;

    if (sum < INT_MIN) return INT_MIN;
    if (sum > INT_MAX) return INT_MAX;

    return sum;
};
```

## 9. Palindrome Number
Given an integer x, return true if x is a

, and false otherwise.

Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.

Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

```js
var isPalindrome = function(x) {
    // negative numbers can't be palindrome
    if (x < 0) return false;

    // convert number to string
    let str = x.toString();

    // check if string is same as its reverse
    let reversed = str.split("").reverse().join("");
    return str === reversed;
};
```

## 10. Regular Expression Matching
Solved
Hard
Topics
premium lock iconCompanies

Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:

    '.' Matches any single character.​​​​
    '*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

 

Example 1:

Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".

Example 2:

Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".

Example 3:

Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".

```js
var isMatch = function(s, p) {
    // base case: if pattern is empty
    if (p.length === 0) return s.length === 0;

    // first match: check if first char matches (or if '.' is present)
    let firstMatch = (s.length > 0 && (s[0] === p[0] || p[0] === '.'));

    // if next char in pattern is '*'
    if (p.length >= 2 && p[1] === '*') {
        // two options:
        // 1. Skip "x*" part in pattern
        // 2. If firstMatch, use one char from s and keep p same
        return (
            isMatch(s, p.slice(2)) || 
            (firstMatch && isMatch(s.slice(1), p))
        );
    } else {
        // no '*', just move forward one step if match
        return firstMatch && isMatch(s.slice(1), p.slice(1));
    }
};

```

## 11. Container With Most Water
Solved
Medium
Topics
premium lock iconCompanies
Hint

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

![alt text](image.png)

Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

Example 2:

Input: height = [1,1]
Output: 1

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let left = 0
    let right = height.length - 1
    let maxWater = 0

    while (left < right) {
        let width = right - left
        let localHeight = Math.min(height[left],height[right])

        let area = width * localHeight
        maxWater = Math.max(maxWater,area)

        if(height[left] < height[right]) {
            left++
        } else {
            right--
        }
    }
    return maxWater
};
```

## 12. Integer to Roman

Seven different symbols represent Roman numerals with the following values:
| Symbol | Value |
|--------|-------|
| I      | 1     |
| V      | 5     |
| X      | 10    |
| L      | 50    |
| C      | 100   |
| D      | 500   |
| M      | 1000  |

```js
var intToRoman = function(num) {
    // Mapping of Roman symbols to values (including special cases)
    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    const symbols = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];

    let result = "";

    for (let i = 0; i < values.length; i++) {
        while (num >= values[i]) {
            num -= values[i];         // subtract the value
            result += symbols[i];     // add matching symbol
        }
    }

    return result;
};
```
Explanation for 1994

1000 → M → 994 left

900 → CM → 94 left

90 → XC → 4 left

4 → IV → done ✅
Result: "MCMXCIV"

## 13. Roman to Integer

Example 1:

Input: s = "III"
Output: 3
Explanation: III = 3.

Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.

Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

```js
var romanToInt = function(s) {
    const values  = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    const symbols = ["M", "CM","D", "CD","C","XC","L","XL","X","IX","V","IV","I"];
 
    let myNumber = 0
    let i = 0

    while (i < s.length) {
        // check of 2 char 
        if( i + 1 < s.length) {
            let twoChar = s.substring(i,i+2)
            let twoCharIndex = symbols.indexOf(twoChar)
            if(twoCharIndex !== -1) {
                myNumber = myNumber + values[twoCharIndex]
                i = i + 2
                continue 
            }
        }

        let oneChar = s[i]
        let oneCharIndex = symbols.indexOf(oneChar)
        if(oneCharIndex !== -1) {
            myNumber = myNumber + values[oneCharIndex]
            i = i + 1
        }
    }
    return myNumber
};

```

## 14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"

Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

```js
var longestCommonPrefix = function(strs) {
    strs.sort()

    let firstText = strs[0]
    let lastText = strs[strs.length - 1]
    let result = ""

    for (let i = 0; i < lastText.length; i++) {
        if(firstText[i] !== lastText[i]) {
            break;
        } else {
            result = result + firstText[i]
        }
    }
    return result
};
```

## 15. 3Sum

```js
 var threeSum = function(nums) {
    let result = []
    nums.sort((a,b) => a - b);
    
    // if(nums.length < 3) return []

    for (let i = 0; i < nums.length - 2; i++) {
        if(i > 0 && nums[i] === nums[i - 1]) continue;

        let left = i + 1
        let right = nums.length - 1
        while (left < right) {
            let sum = nums[i] + nums[left] + nums[right]
            if(sum === 0) {
                result.push([nums[i] , nums[left] , nums[right]])
                while (left < right && nums[left] === nums[left + 1]) left++
                while (left < right && nums[right] === nums[right - 1]) right--
                left++
                right--
            } else if (sum < 0){
                left++
            } else {
                right--
            }
        }
    }
    return result
};

```

## 16. 3Sum Closest

Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.

Example 1:

Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

Example 2:

Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).

```js
var threeSumClosest = function(nums, target) {
    nums.sort((a, b) => a - b);
    let closetNumer = nums[0] + nums[1] + nums[2]
    
    for (let i = 0; i < nums.length - 2; i++) {
        let left = i + 1
        let right = nums.length - 1

        while (left < right) {
            let sum = nums[i] + nums[left] + nums[right]

            if(Math.abs(sum - target) < Math.abs(closetNumer - target)) {
                closetNumer = sum
            }

            if(sum < target) {
                left++
            } else if (sum > target) {
                right--
            } else {
                return closetNumer
            }
        }
    }
    return closetNumer
};
```

## 17. Letter Combinations of a Phone Number

Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![alt text](image-2.png)

Example 1:

Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

Example 2:

Input: digits = ""
Output: []

Example 3:

Input: digits = "2"
Output: ["a","b","c"]

```js
var letterCombinations = function(digits) {
    if (digits.length === 0) return [];

    const phoneMap = {
        "2": "abc",
        "3": "def",
        "4": "ghi",
        "5": "jkl",
        "6": "mno",
        "7": "pqrs",
        "8": "tuv",
        "9": "wxyz"
    };
    // My Code
    let result = []

    let backStack = (index,path) => {
        if(path.length === digits.length) {
            result.push(path)
            return;
        }

        let letters = phoneMap[digits[index]]
        for(letter of letters) {
            backStack(index + 1, path + letter)
        }
    }

    backStack(0,"")
    return result
}
```

## 18. 4Sum

Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

    0 <= a, b, c, d < n
    a, b, c, and d are distinct.
    nums[a] + nums[b] + nums[c] + nums[d] == target

You may return the answer in any order.

 

Example 1:

Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

Example 2:

Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]

```js
var fourSum = function(nums, target) {
    let result = []
    nums.sort((a,b) => a - b)

    let n = nums.length

    for (let i = 0; i < n - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;

        for (let j = i + 1; j < n - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) continue;

            let left = j + 1
            let right = n - 1

            while(left < right) {
                let sum = nums[i] + nums[j] + nums[left] + nums[right]
                if(sum === target) {
                    result.push([nums[i],nums[j],nums[left],nums[right]])

                    while(left < right && nums[left] === nums[left + 1]) left++
                    while(left < right && nums[right] === nums[right - 1]) right--
                    right--
                    left++
                } else if (sum < target) {
                    left++
                } else {
                    right--
                }
            }
        }
    }
    return result
};

```

## 19. Remove Nth Node From End of List

![alt text](image-3.png)

Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:

Input: head = [1], n = 1
Output: []

Example 3:

Input: head = [1,2], n = 1
Output: [1]

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(0,head)
    let fast = dummy
    let slow = dummy

    for (let i = 0; i <= n; i++) {
        fast = fast.next
    }

    while (fast) {
        fast = fast.next
        slow = slow.next
    }

    slow.next = slow.next.next
    return dummy.next
};
```

## 20. Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

    Open brackets must be closed by the same type of brackets.
    Open brackets must be closed in the correct order.
    Every close bracket has a corresponding open bracket of the same type.

Example 1:

Input: s = "()"

Output: true

Example 2:

Input: s = "()[]{}"

Output: true

```js
var isValid = function(s) {
     let myStack = []
     let myMap = {
        '[':']',
        '{':'}',
        '(':')'
     }

     for (let char of s) {
        if (char === '[' || char === '(' || char === '{') {
            myStack.push(myMap[char])
        } else {
            if(myStack.length === 0 || myStack.pop() !== char){
                return false
            }
        }
     }

     return myStack.length === 0
};

```

## 21. Merge Two Sorted Lists

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

![alt text](image-4.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(list1, list2) {
    let dummy = new ListNode(0)
    let myLinkedList = dummy

    while (list1 !== null && list2 !== null) {
        if (list1.val < list2.val) {
            myLinkedList.next = list1
            list1 = list1.next
        } else {
            myLinkedList.next = list2
            list2 = list2.next
        }
        
        myLinkedList = myLinkedList.next
    }

    if(list1 != null) {
        myLinkedList.next = list1
    } else {
        myLinkedList.next = list2
    }

    return dummy.next
};
```

## 22. Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.


Example 1:

Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]

Example 2:

Input: n = 1
Output: ["()"]

```js
var generateParenthesis = function(n) {
    let result = [];

    function backtrack(current, open, close) {
        // if the string is complete
        if (current.length === n * 2) {
            result.push(current);
            return;
        }

        // if we can add "(", do it
        if (open < n) {
            backtrack(current + "(", open + 1, close);
        }

        // if we can add ")", do it
        if (close < open) {
            backtrack(current + ")", open, close + 1);
        }
    }

    backtrack("", 0, 0); // start with empty string
    return result;
};

```

## 23. Merge k Sorted Lists
Solved
Hard
Topics
premium lock iconCompanies

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

 

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted linked list:
1->1->2->3->4->4->5->6

Example 2:

Input: lists = []
Output: []

Example 3:

Input: lists = [[]]
Output: []

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if (lists.length === 0) return null;

    // Helper to merge 2 lists (from LeetCode 21)
    function mergeTwoLists(l1, l2) {
        let dummy = new ListNode(0);
        let current = dummy;

        while (l1 !== null && l2 !== null) {
            if (l1.val < l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        current.next = l1 || l2;
        return dummy.next;
    }

    // Merge lists in pairs until only one remains
    while (lists.length > 1) {
        let mergedLists = [];

        for (let i = 0; i < lists.length; i += 2) {
            let l1 = lists[i];
            let l2 = (i + 1 < lists.length) ? lists[i + 1] : null;
            mergedLists.push(mergeTwoLists(l1, l2));
        }

        lists = mergedLists; // reduce problem size
    }

    return lists[0];
};

```

## 24. Swap Nodes in Pairs
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

 

Example 1:

Input: head = [1,2,3,4]

Output: [2,1,4,3]

Explanation:

Example 2:

Input: head = []

Output: []

Example 3:

Input: head = [1]

Output: [1]

Example 4:

Input: head = [1,2,3]

Output: [2,1,3]

![alt text](image-5.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let dummy = new ListNode(0,head); // create a dummy node
    // dummy.next = head;
    let prev = dummy;

    while (head && head.next) {
        // Nodes to swap
        let first = head;
        let second = head.next;

        // Swapping
        prev.next = second;
        first.next = second.next;
        second.next = first;

        // Move pointers
        prev = first;
        head = first.next;
    }

    return dummy.next;
};

```

## 25. Reverse Nodes in k-Group

Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

 

Example 1:

![alt text](image-6.png)

Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:

![alt text](image-7.png)

Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    if (!head || k === 1) return head;

    // Dummy node to simplify head handling
    let dummy = new ListNode(0, head);
    let prevGroupEnd = dummy;

    while (true) {
        // Find the kth node from prevGroupEnd
        let kth = getKthNode(prevGroupEnd, k);
        if (!kth) break; // Not enough nodes left

        let groupStart = prevGroupEnd.next;
        let nextGroupStart = kth.next;

        // Reverse this group
        reverse(groupStart, kth);

        // Connect previous group to new head
        prevGroupEnd.next = kth;
        groupStart.next = nextGroupStart;

        // Move prevGroupEnd to end of current group
        prevGroupEnd = groupStart;
    }

    return dummy.next;
};

// Helper: find kth node from current node
function getKthNode(curr, k) {
    while (curr && k > 0) {
        curr = curr.next;
        k--;
    }
    return curr;
}

// Helper: reverse nodes from start to end (inclusive)
function reverse(start, end) {
    let prev = null;
    let curr = start;
    let stop = end.next;

    while (curr !== stop) {
        let temp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = temp;
    }
}

```

## 26. Remove Duplicates from Sorted Array

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Example 1:

```
Example 1:

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

Example 2:
```

Example 2:

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let i = 0;
    for (let j = 1; j < nums.length; j++) {
        if (nums[j] !== nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
    if (nums.length === 0) return 0

    let slowIndex = 0
    for (let fastIndex = 1; fastIndex < nums.length; fastIndex++) {
        if(nums[fastIndex] !== nums[slowIndex]) {
            slowIndex++
            nums[slowIndex] = nums[fastIndex]
        }
    }
    return slowIndex + 1
};
```

## 27. Remove Element

Example 1:

Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).

Example 2:

Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let left = 0;
    for (let right = 0; right < nums.length; right++) {
        if (nums[right] !== val) {
            nums[left] = nums[right]
            left++
        }
    }
    return left
};
    let k = 0; // write index

    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== val) {
            nums[k] = nums[i]; 
            k++;
        }
    }

    return k;
};

```

## 28. Find the Index of the First Occurrence in a String

Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

 

Example 1:

Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.

Example 2:

Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    for (let i = 0; i <= haystack.length - needle.length; i++) {
        if (haystack.substring(i, i + needle.length) === needle) {
            return i;
        }
    }
    return -1;
};

var strStr = function(haystack, needle) {
    return haystack.indexOf(needle);

};
```

## 29, Divide Two Integers

Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.

The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.

Return the quotient after dividing dividend by divisor.

Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.

 

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = 3.33333.. which is truncated to 3.

Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = -2.33333.. which is truncated to -2.

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    // Handle edge case: overflow
    if (dividend === -2147483648 && divisor === -1) {
        return 2147483647; // prevent overflow
    }

    // Get sign of result
    let sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;

    // Work with positive numbers
    let a = Math.abs(dividend);
    let b = Math.abs(divisor);
    let result = 0;

    // Subtract divisor multiples using bit shifting
    while (a >= b) {
        let temp = b, multiple = 1;
        while (a >= (temp << 1)) {
            temp <<= 1;         // double the divisor
            multiple <<= 1;     // double the count
        }
        a -= temp;
        result += multiple;
    }

    return sign * result;
};

    if (needle.length === 0) return 0;

    for (let i = 0; i <= haystack.length - needle.length; i++) {
        let match = true;

        for (let j = 0; j < needle.length; j++) {
            if (haystack[i + j] !== needle[j]) {
                match = false;
                break;
            }
        }

        if (match) {
            return i;
        }
    }

    return -1;
};


```

## 31. Next Permutation

A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

    For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].

The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

    For example, the next permutation of arr = [1,2,3] is [1,3,2].
    Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
    While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.

Given an array of integers nums, find the next permutation of nums.

The replacement must be in place and use only constant extra memory.

 

Example 1:

Input: nums = [1,2,3]
Output: [1,3,2]

Example 2:

Input: nums = [3,2,1]
Output: [1,2,3]

Example 3:

Input: nums = [1,1,5]
Output: [1,5,1]

 

Constraints:

    1 <= nums.length <= 100
    0 <= nums[i] <= 100


### code -

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    let n = nums.length;
    let i = n - 2;

    // Step 1: Find the pivot
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }

    if (i >= 0) {
        // Step 2: Find next bigger element
        let j = n - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }
        // Swap pivot and next larger
        [nums[i], nums[j]] = [nums[j], nums[i]];
    }

    // Step 3: Reverse the decreasing suffix
    let left = i + 1;
    let right = n - 1;
    while (left < right) {
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++;
        right--;
    }
};
```

## 32. Longest Valid Parentheses
Hard
Topics
premium lock iconCompanies

Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses

.


Example 1:

Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".

Example 2:

Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".

Example 3:

Input: s = ""
Output: 0

```js
var longestValidParentheses = function(s) {
    let stack = [-1]; // base index
    let maxLen = 0;

    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i);
        } else {
            stack.pop();

            if (stack.length === 0) {
                // reset base
                stack.push(i);
            } else {
                // valid substring length
                let len = i - stack[stack.length - 1];
                maxLen = Math.max(maxLen, len);
            }
        }
    }

    return maxLen;
};

```

## 33. Search in Rotated Sorted Array
Medium
Topics
premium lock iconCompanies

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly left rotated at an unknown index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be left rotated by 3 indices and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

Example 3:

Input: nums = [1], target = 0
Output: -1

```js
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        }

        // Left half is sorted
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // Right half is sorted
        else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
};

```

## 34.  Find First and Last Position of Element in Sorted Array
Solved
Medium
Topics
premium lock iconCompanies

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

Example 3:

Input: nums = [], target = 0
Output: [-1,-1]

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(arr, target) {

    function findMeIndex(isFirst) {
        let left = 0
        let right = arr.length - 1
        let index = -1

        while (left <= right) {
            let mid = Math.floor((left + right) / 2)
            if (arr[mid] === target) {
                index = mid

                if(isFirst) {
                    right = mid - 1
                } else {
                    left = mid + 1
                }
            } else if (arr[mid] < target) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
        return index
    }

    return [findMeIndex(true),findMeIndex(false)] 
};

```

## 35. Search Insert Position
Solved
Easy
Topics
premium lock iconCompanies

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1

Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid; // found exact position
        }

        if (nums[mid] < target) {
            left = mid + 1; // search right
        } else {
            right = mid - 1; // search left
        }
    }
    // left is the insert position
    return left;
};


```
## 36. Valid Sudoku
Solved
Medium
Topics
premium lock iconCompanies

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

    Each row must contain the digits 1-9 without repetition.
    Each column must contain the digits 1-9 without repetition.
    Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:

    A Sudoku board (partially filled) could be valid but is not necessarily solvable.
    Only the filled cells need to be validated according to the mentioned rules.
![alt text](image-8.png)

```js
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
    let rows =  Array.from({length :9}, () => new Set())
    let cols =  Array.from({length :9}, () => new Set())
    let boxs =  Array.from({length :9}, () => new Set())

    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            let val = board[r][c]

            if(val === '.') continue

            let boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3)

            if (rows[r].has(val) || 
                cols[c].has(val) ||
                boxs[boxIndex].has(val)
            ) {
                return false
            }

            rows[r].add(val)
            cols[c].add(val) 
            boxs[boxIndex].add(val) 
        }
    }
    return true 
};
```

## 37. Sudoku Solver

Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

    Each of the digits 1-9 must occur exactly once in each row.
    Each of the digits 1-9 must occur exactly once in each column.
    Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.

The '.' character indicates empty cells.

![alt text](image-9.png)

```js
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {

    function isValid(row, col, ch) {
        for (let i = 0; i < 9; i++) {
            // check row
            if (board[row][i] === ch) return false;

            // check column
            if (board[i][col] === ch) return false;

            // check 3x3 box
            let r = Math.floor(row / 3) * 3 + Math.floor(i / 3);
            let c = Math.floor(col / 3) * 3 + (i % 3);
            if (board[r][c] === ch) return false;
        }
        return true;
    }

    function solve() {
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {

                if (board[r][c] === '.') {

                    for (let num = 1; num <= 9; num++) {
                        let ch = num.toString();

                        if (isValid(r, c, ch)) {
                            board[r][c] = ch; // try

                            if (solve()) return true; // move forward

                            board[r][c] = '.'; // undo
                        }
                    }

                    return false; // no number worked
                }
            }
        }
        return true; // solved
    }

    solve();
};
```

## 38.Count and Say
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

    countAndSay(1) = "1"
    countAndSay(n) is the run-length encoding of countAndSay(n - 1).

Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".

Given a positive integer n, return the nth element of the count-and-say sequence.

 

Example 1:

Input: n = 4

Output: "1211"

Explanation:

countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"

Example 2:

Input: n = 1

Output: "1"

Explanation:

This is the base case.

```js
var countAndSay = function(n) {
    let sequence = "1"; // starting point

    // build sequence from 2 to n
    for (let step = 2; step <= n; step++) {
        let nextSequence = "";
        let count = 1;

        // read the current sequence
        for (let position = 1; position <= sequence.length; position++) {
            if (sequence[position] === sequence[position - 1]) {
                count++;
            } else {
                nextSequence += count + sequence[position - 1];
                count = 1;
            }
        }

        sequence = nextSequence;
    }

    return sequence;
};
```